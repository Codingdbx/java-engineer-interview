## 2020版Java分布式面试题

### 1. CAP理论？

分布式系统中有一个重要理论：CAP。 该理论提到了分布式系统中的3个特性：

- Consistency 数据一致性

  分布式系统中，数据会存在多个副本中，有一些问题会导致写入数据时，一部分副本成功、一部分副本失败，造成数据不一致。满足一致性就要求对数据的更新操作成功后，多副本的数据必须保持一致。

- Availability 可用性

  在任何时候客户端对集群进行读写操作时，请求能够正常响应。

- Partition Tolerance 分区容忍性

  发生通信故障时，集群被分割为多个无法通信的分区时，集群仍然可用。

CAP 理论指出：这3个特性不可能同时满足，最多满足2个。 

Eureka 是弱一致性的AP，ZooKeeper  就是强一致性的CP。 

### 2. BASE 理论？

核心思想：

- **基本可用（BasicallyAvailable）**

  指分布式系统在出现故障时，允许损失部分的可用性来保证核心可用。

- **软状态（SoftState）**

  指允许分布式系统存在中间状态，该中间状态不会影响到系统的整体可用性。

- **最终一致性（EventualConsistency）**

  指分布式系统中的所有副本数据经过一定时间后，最终能够达到一致的状态。

### 3. 分布式事务了解吗？你们是如何解决分布式事务问题的？ 

分布式事务的实现主要有以下 6 种方案：

- XA 方案
- TCC 方案
- SAGA 方案
- 本地消息表
- 可靠消息最终一致性方案
- 最大努力通知方案

#### TCC 方案

TCC 的全称是： `Try` 、 `Confirm` 、 `Cancel` 。

- Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行**锁定或者预留**。
- Confirm 阶段：这个阶段说的是在各个服务中**执行实际的操作**。
- Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要**进行补偿**，就是执行已经执行成功的业务逻辑的回滚操作。（把那些执行成功的回滚）

一般来说跟**钱**相关的，跟钱打交道的，**支付**、**交易**相关的场景，我们会用 TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题。 

TCC开发成本很大，所有接口都要写三次，因为涉及TCC的三个阶段。  

#### 可靠消息最终一致性方案

基于 MQ 来实现事务。比如阿里的 RocketMQ 就支持消息事务。

1. A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了；
2. 如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；
3. 如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；
4. mq 会自动**定时轮询**所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。
5. 这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。

### 4. 你们公司是如何处理分布式事务的？

如果你真的被问到，可以这么说，我们某某特别严格的场景，用的是 TCC 来保证强一致性；然后其他的一些场景基于阿里的 RocketMQ 来实现分布式事务。

你找一个严格资金要求绝对不能错的场景，你可以说你是用的 TCC 方案；如果是一般的分布式事务场景，订单插入之后要调用库存服务更新库存，库存数据没有资金那么的敏感，可以用可靠消息最终一致性方案。



### 5. 分布式场景下怎么保证接口的幂等性？

数据库层面做一个唯一约束。

并发度比较高的场景下，比如下单后的订单号放到缓存里，每次下单判断订单号存不存在缓存中。









