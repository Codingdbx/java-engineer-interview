## JVM与调优面试题

### 1. 说说JVM原理？

`JVM` 是 `Java Virtual Machine`（Java虚拟机）的缩写，它是整个`Java`实现跨平台的最核心的部分，所有的`Java`程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，也就是说.class文件并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。`JVM`是Java平台的基础，和实际的机器一样，它也有自己的指令集，并且在运行时操作不同的内存区域。`JVM`通过抽象操作系统和CPU结构，提供了一种与平台无关的代码执行方法，即与特殊的实现方法、主机硬件、主机操作系统无关。`JVM`的主要工作是解释自己的指令集（即字节码）到CPU的指令集或对应的系统调用，保护用户免被恶意程序骚扰。`JVM`对上层的`Java`源文件是不关心的，它关注的只是由源文件生成的类文件（.class文件）。

### 2. 说一下 JVM 的主要组成部分？及其作用？

* 类加载器（`ClassLoader`）
* 运行时数据区（`Runtime Data Area`）
* 执行引擎（`Execution Engine`)
* 本地库接口（`Native Interface`)

### 3. 什么是类加载器，类加载器有哪些？

（1）启动类加载器（ `Bootstrap ClassLoader` ）

这个类加载器负责将存放在JAVA_HOME/lib下的，或者被`-Xbootclasspath`参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用。

（2）扩展类加载器（`Extension ClassLoader`）

这个加载器负责加载JAVA_HOME/lib/ext目录中的，或者被`java.ext.dirs`系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。

（3）应用程序类加载器（`Application ClassLoader`）

这个加载器是 `ClassLoader` 中的 `getSystemClassLoader()` 方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（`classpath`）上所指定的类库，可直接使用这个加载器，如果应用程序没有自定义自己的类加载器，一般情况下这个就是程序中默认的类加载器。

### 4. 类加载器双亲委派模型机制？

双亲委派模型：

双亲委派模型要求除了顶层的启动类加载器外，其他的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承关系来实现，而是都使用组合关系来复用父加载器的代码。

工作过程：

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传递到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

好处：

Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类Object，它放在 `rt.jar`中，无论哪一个类加载器要加载这个类，最终都是委派给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类，判断两个类是否相同是通过`ClassLoader`这种方式进行的，所以哪怕是同一个.class文件如果被两个`ClassLoader`加载，那么他们也是不同的类。

### 5. 说一下 JVM 运行时数据区？ 

Java 虚拟机规范规定的区域分为以下 5 个部分： 

* 程序计数器（Program Counter Register）：是一块较小的内存空间，当前线程所执行的字节码的行号指示器。
* Java 虚拟机栈（Java Virtual Machine Stacks）：线程私有的，用于线程独有的方法调用、方法参数等信息。 
* 本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的。 
*  Java 堆（Java Heap）：所有线程共享的区域，几乎所有的对象实例都在这里分配内存。 
* 方法区（Method Area）：所有线程共享的区域，运行时常量池是方法区的一部分，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。 

### 6. Java 内存分配？JMM内存模型？

首先，`JVM`将内存分为主内存和工作内存两个部分。

* 主内存

  主要包括方法区和 Java 堆，所有的变量都存储在主内存中，主内存对所有线程都是共享的。

  堆内存分配区域：

  1.年轻代（Young Generation）

  2.年老代（Old Generation）

  3.持久代（Permanent Generation）

* 工作内存

  每条线程都有自己的工作内存，它们之间无法直接访问。

### 7. 说一下类加载过程？

类加载分为以下 5 个步骤： 

* 加载：根据类的全限定名把相应的 class 文件加载到内存中。

* 验证：验证加载的 class 文件的正确性。 

* 准备：给类分配内存空间并设置类变量初始值的阶段。

* 解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个 标示，而在直接引用直接指向内存中的地址。

* 初始化：开始执行 Java 程序代码。

  将一个类中所有被static关键字标识的代码统一执行一遍。

  * 如果执行的是静态变量，那么就会使用用户指定的值覆盖之前在准备阶段设置的初始值；

  * 如果执行的是static代码块，那么在初始化阶段，`JVM`就会执行static代码块中定义的所有操作。

### 8. 描述一下 JVM 加载 Class 文件的原理机制?

Java中的所有类，都需要由类加载器装载到`JVM`中才能运行。类加载器本身也是一个类，而它的工作就是把.class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。

类装载方式，有两种 ：

1.隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到`JVM`中。

2.显式装载， 通过class.forname()等方法，显式加载需要的类。

Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到`JVM`中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。

Java的类加载器有三个，对应Java的三种类:

`Bootstrap ClassLoader`  ：启动类加载器，是虚拟机自身的一部分。负责将存放在\lib目录中的类库加载到虚拟机中。其无法被Java程序直接引用。

`Extension ClassLoader`  ： 负责加载扩展类(就是继承类和实现类)。

`Application ClassLoader`  ：负责加载用户类路径（`classpath`）上所指定的类库(程序员自定义的类)。



### 9. 简述 Java 垃圾回收机制？

在Java中，程序员是不需要主动的管理一个对象的内存占用的，而是由虚拟机自行的执行。在`JVM`中，有一个垃圾回收线程，它以低优先级运行。会不定时的去检测内存中没有用的对象，然后回收这块内存空间。

GC 是指垃圾收集(Garbage Collection)。

堆内存分配区域：

1.年轻代（Young Generation）

2.年老代（Old Generation）

3.持久代（Permanent Generation）

 ![img](https://upload-images.jianshu.io/upload_images/3789193-f00c8fe4be1cb580.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp) 

大多数情况下，创建的对象在Eden区分配，当Eden区满了之后，`JVM`会进行一次 `Minor GC`回收。长期存活的对象会进入老年代，大对象会直接进入老年代。

* `Minor GC`  新生代GC

  指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以 `Minor GC` 非常频繁，回收速度也比较快。

* `Major GC`  老年代GC

  指发生在老年代的垃圾收集动作，经常会伴随至少一次的`Minor GC`，但非绝对。`Major GC` 一般要比`Minor GC` 慢10倍以上。
  
* `Full GC`   全量回收GC

  年轻代，老年代一块回收。



### 10. 在 Java 中，对象什么时候可以被垃圾回收？

当一个对象到`GC Roots`不可达时，在下一个垃圾回收周期中尝试回收该对象，如果该对象重写了finalize()方法，并在这个方法中成功自救(将自身赋予某个引用)，那么这个对象不会被回收。但如果这个对象没有重写finalize()方法或者已经执行过这个方法，也自救失败，该对象将会被回收。 

### 11. 内存泄露与内存溢出区别？

* out of memory 

  内存溢出 ，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory，那就是内存溢出。

* memory leak 

  内存泄露 ，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。

memory leak会最终会导致out of memory！ 

### 12. Java 中会存在内存泄漏吗，何时产生内存泄露？ 请简单描述？

会，如下：

1.静态集合类：在使用Set，Vector，HashMap等集合类的时候需要特别注意，可能发生内存泄漏。当这些集合被定义成静态的时候，由于他们的生命周期和程序一样长，这时候就可能发生内存泄漏。

2.监听器：在java中，我们经常会使用到监听器（listener），但往往释放对象的时候却没有去删除这些监听器从而增加了内存泄漏的机会。

3.各种连接：数据库连接，网络连接，io连接。如果不显示调用器close()方法的话是不会自动关闭的，这些连接就不能被GC回收从而导致内存泄漏。

4.外部模块的引用：调用外部模块的时候，没释放可能导致后继的一系列的对象都没释放。

5.单例模式：由于单例的静态特性使得其生命周期跟应用的生命周期相同。单例对象在初始化后将在`JVM`的整个生命周期中存在，如果单例对象持有外部的引用，那么外部对象将不能被`JVM`正常回收。

### 13. 说一下 JVM 有哪些垃圾回收算法？Java 中垃圾收集的方法有哪些？ 

* 标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，碎片化。
* 标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。
* 复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存占用高。
* 分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。 

### 14. 怎么判断对象是否可以被回收？ 如何判断一个对象是否存活？（或者 GC 对象的判定方法）

一般有两种方法来判断： 

* 引用计数器算法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题。
* 可达性分析算法：当一个对象到 `GC Roots` 没有任何引用链相连时，则证明此对象是可以被回收的。 

###  15. 说一下 JVM 有哪些垃圾回收器？ 

`JDK1.8` 默认使用的是 PS + PO 垃圾回收器。垃圾回收的发展路线是根据内存的增长而演进的。

* `Serial`：最早的单线程回收器。停止一切活动的线程 `STW`(stop the world) ，回收垃圾，适用内存小（几十M）的应用。

* `Serial Old`：老年代区的单线程回收器。

* `Parallel Scavenge` ：多线程回收器，也是 `STW`，适用内存大点（几个G）的应用。

* `Parallel Old` ：老年代区多线程回收器。

* `ParNew`：多线程回收器，不再需要长时间的`STW`。

* `CMS`：concurrent mark sweep。老年代区`GC`，主要的4个阶段：

  * initial mark  初始标记
  * concurrent mark  并发标记，工作线程与垃圾回收线程出现并发。会出现漏标情况。
  * remark   重新标记/最终标记
  * concurrent sweep  并发清除

  采用三色扫描法：`Incremental Update `  增量更新

* `G1`：缩短了`STW`时间，并发回收效率比较高。

  采用三色扫描法：`SATB`

* `ZGC`：

* `Epsilon`：

* `Shenandoah`：

![1603351830454](C:\Users\Dongbixi\AppData\Roaming\Typora\typora-user-images\1603351830454.png)



`JVM` 调优：最简单的方式就是重启！

`java -XX:+PrintCommandLineFlags -version`  查看`JVM`启动时的参数

![1603375876452](C:\Users\Dongbixi\AppData\Roaming\Typora\typora-user-images\1603375876452.png)

![1603376077188](C:\Users\Dongbixi\AppData\Roaming\Typora\typora-user-images\1603376077188.png)



`JVM` 参数：   `java -Xms30m -Xmx30m -XX:+PrintGC`

-`Xms` 最小堆

-`Xmx` 最大堆

```java
top             //查看cpu,内存占用情况
jps  1320       //查看java的所有进程
jinfo  1320      //打印一些进程的相关信息
jstat -gc 1320   //查看整个堆内存分配的一些情况  jstat -gc 1320 500 每隔500秒刷新一次
jstack 1320      //把当前java进程中的所有线程都列出来，用来发现有没有死锁
```

### `CPU100`% 怎么排查？ 

业务线程飙高还是`gc`线程飙高

使用`jstack` 命令

阿里的`arthas-boot.jar`   thread 命令 可以看到具体的线程信息。

### `OOM` 怎么排查？

 **1. 清楚从程序角度，有哪些原因导致FGC？** 

- 大对象：系统一次性加载了过多数据到内存中（比如SQL查询未做分页），导致大对象进入了老年代。
- 内存泄漏：频繁创建了大量对象，但是无法被回收（比如IO对象使用完后未调用close方法释放资源），先引发FGC，最后导致OOM。
- 程序频繁生成一些长生命周期的对象，当这些对象的存活年龄超过分代年龄时便会进入老年代，最后引发FGC。 （即本文中的案例）
- 程序BUG导致动态生成了很多新类，使得 Metaspace 不断被占用，先引发FGC，最后导致OOM.
- 代码中显式调用了gc方法，包括自己的代码甚至框架中的代码。
- JVM参数设置问题：包括总内存大小、新生代和老年代的大小、Eden区和S区的大小、元空间大小、垃圾回收算法等等。

 **2. 清楚排查问题时能使用哪些工具？** 

- 公司的监控系统：大部分公司都会有，可全方位监控JVM的各项指标。

- JDK的自带工具，包括jmap、jstat等常用命令：

  \# 查看堆内存各区域的使用率以及GC情况

  jstat -gcutil -h20 pid 1000

  \# 查看堆内存中的存活对象，并按空间排序

  jmap -histo pid | head -n20

  \# dump堆内存文件

  jmap -dump:format=b,file=heap pid

- 可视化的堆内存分析工具：JVisualVM、MAT等。

**3. 排查指南？**

- 查看监控，以了解出现问题的时间点以及当前FGC的频率（可对比正常情况看频率是否正常）
- 了解该时间点之前有没有程序上线、基础组件升级等情况。
- 了解JVM的参数设置，包括：堆空间各个区域的大小设置，新生代和老年代分别采用了哪些垃圾收集器，然后分析JVM参数设置是否合理。
- 再对步骤1中列出的可能原因做排除法，其中元空间被打满、内存泄漏、代码显式调用gc方法比较容易排查。
- 针对大对象或者长生命周期对象导致的FGC，可通过 jmap -histo 命令并结合dump堆内存文件作进一步分析，需要先定位到可疑对象。
- 通过可疑对象定位到具体代码再次分析，这时候要结合GC原理和JVM参数设置，弄清楚可疑对象是否满足了进入到老年代的条件才能下结论。



### 16. System.gc() 和 Runtime.gc() 会做什么事情？

* `System.gc()`

  ```
  invokestatic java/lang/System.gc()V
  ```

* `Runtime.getRuntime().gc()`

  ```
  invokestatic java/lang/Runtime.getRuntime()Ljava/lang/Runtime;
  invokevirtual java/lang/Runtime.gc()V
  ```

实际运行起来性能几乎一样，没有什么区别。`System.gc()` 的字节码会短点。如果对字节码大小非常非常敏感的话建议用`System.gc()`。从通常的代码习惯说也是`System.gc()`用得多些。

调用两个方法都是让 `JVM` 进行垃圾对象的回收，但是系统什么时候回收，不确定，只能理论上尽快回收。

### 强引用、软引用、弱引用、虚引用的性质？

* 强引用

  从来不会被回收。

* 软引用

  在内存不足的时候被回收，可以用来做缓存。例如：图片在内存中处理。

* 弱引用

  在`gc`运行时会直接被回收。

* 虚引用

  管理直接内存，把不在`jvm`内存中分配的对象放到一个队列里面做处理。

  



### 17. finalize() 方法什么时候被调用？析构函数 finalization 目的是什么？

当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。

finalization 目的：给对象一个自救机会，看能不能与引用链上的对象相关联，如果关联成功，在下一次标记的时候从“即将回收的对象”集合中移除；如果失败那么该对象基本就会被真的回收 。

### 18. 如果对象的引用被置为 null，垃圾收集器是否会立即释放对象占用的内存？

 不会，在下一个垃圾回调周期中，这个对象将是被可回收的。 他还要进行一次自救。

### 19. 什么是分布式垃圾回收（DGC）？它是如何工作的？

  1) Java虚拟机中，一个远程对象不仅会被本地虚拟机内的变量引用，还会被远程引用。

  2) 只有当一个远程对象不受到任何本地引用和远程引用，这个远程对象才会结束生命周期。  

当客户机创建（序列化）远程引用时，会在服务器端 DGC 上调用 dirty()。当客户机完成远程引用后，它会调用对应的 clean() 方法。  

针对远程对象的引用由持有该引用的客户机租用一段时间。租期从收到 dirty()    调用开始。在此类租约到期之前，客户机必须通过对远程引用额外调用 dirty()    来更新租约。如果客户机不在租约到期前进行续签，那么分布式垃圾收集器会假设客户机不再引用远程对象。

### 20. 串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？

### 21. 简述 Java 内存分配与回收策率以及 Minor GC 和 Major GC。

### 22. JVM 的永久代中会发生垃圾回收么？

永生代也是可以回收的，条件是：

1.该类的实例都被回收。 

2.加载该类的classLoader已经被回收。

3.该类不能通过反射访问到其方法，而且该类的java.lang.class没有被引用 

当满足这3个条件时，是可以回收，但回不回收还得看jvm。 

 