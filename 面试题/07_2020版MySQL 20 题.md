## 2020版MySQL面试题

### 1.数据库设计三大范式是什么？

* 确保每列原子性，避免数据冗余。
* 确保有一列作为主键，与其他列可以相关联。   
* 确保每列都是与主键直接相关，而不是间接相关。

### 2.数据库五大约束是什么？    

* PRIMARY KEY 设置主键约束    
* UNIQUE  设置唯一性约束，不能有重复值    
* DEFAULT 默认值约束    
* NOT NULL 设置非空约束，该字段不能为空    
* FOREIGN key 设置外键约束

### 3. drop、 truncate、delete区别是什么？

* drop    drop 删除整个表。
* truncate    truncate 不能删除行数据，要删就要把表清空。
* delete     delete 语句用于删除表中的行。

级别来分的话  drop > truncate > delete。

### 4. char 和 varchar 的区别是什么？

* `char(n)` ：固定长度类型

  优点：效率高。

  缺点：占用空间。

  适用场景：存储密码的 `md5` 值，固定长度的，使用 char 非常合适。 

* `varchar(n)` ：可变长度

  从空间上考虑 `varcahr` 比较合适，从效率上考虑 char 比较合适。

### 5. 说一下 MySQL 常用的数据库引擎？ 

* `InnoDB` 引擎

  支持事务，支持表锁，行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。 但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 `select count(*) from table` 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的，所以在并发度较高的场景下使用会提升效率的。 

* `MyIASM` 引擎

  不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新 语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 `InnoDB` 不同的是，`MyIASM` 引擎是保存了表的行数，于是当进行 `select count(*) from table` 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以， 如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 `MyIASM` 作为 数据库引擎的首选。 

### 6. MySQL 几种连接的区别？

* 内连接（inner join）返回结果集A,B共有的部分。

* 外连接

  * left join     返回左表的独有和A,B的共有的部分。   
  * right join    返回右表的独有和A,B的共有的部分。  

* 全连接（full join/union）  返回结果集A，B独有和共有的部分，不包括重复行。

* 交叉连接（笛卡尔积）    A与B的笛卡尔积，记作AxB。交叉连接不能使用ON关键字，但可以使用WHERE子句定义连接条件。

  ```html
  例如，A={a,b},B={0,1,2},则
  AxB={<a,o>,<a,1>,<a,2>,<b,0>,<b,1>,<b,2>}
  BxA={<0,a>,<0,b>,<1,a>,<1,b>,<2,a>,<2,b>}
  ```

### 7. Union和Union All区别？

Union 和 Union All 统称为全连接。

* Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序。
* Union All：对两个结果集进行并集操作，包括重复行，不进行排序。

### 8. 说一下 MySQL 的行锁和表锁？ 

`MyISAM` 只支持表锁，`InnoDB` 支持表锁和行锁，默认为行锁。 

* 表级锁：粒度大，开销小，不会出现死锁。并发量最低。
* 行级锁：粒度小，开销大，会出现死锁。并发度最高。 



### 9. MySQL事务，JDBC事务，Spring事务怎么开启？

* MYSQL 事务：
  * 用 BEGIN, ROLLBACK, COMMIT来实现
    * BEGIN 开始一个事务
    * ROLLBACK 事务回滚
    * COMMIT 事务确认
  * 直接用 SET 来改变 MySQL 的自动提交模式
    * SET AUTOCOMMIT=0 禁止自动提交
    * SET AUTOCOMMIT=1 开启自动提交

* JDBC事务：

  JDBC事务默认是开启的，并且是自动提交 。开启手动事务的关键是`con.setAutoCommit(false)` 。

  * 手动提交事务：`con.commit()`
  * 手动回滚： `con.rollback()` 
  * 关闭连接：`con.close()`

* Spring事务：
  * 编程式事务管理 
    *  需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法。
  * 声明式事务管理 
    *  基于@Transactional 注解



### 10. 说一下 事务的 ACID 是什么？

ACID是原子性（atomicity）、一致性（consistency）、隔离性（isolation）、持久性（durability）的缩写。

* 原子性：即不可分割，事务要么全部被执行，要么全部不执行。如果事务的所有子事务全部提交成功，则所有的数据库操作被提交，数据库状态发生变化；如果有子事务失败，则其他子事务的数据库操作被回滚，即数据库回到事务执行前的状态，不会发生状态转换。
* 一致性：事务的执行使得数据库从一种正确状态转换成另外一种正确状态。
* 隔离性：在事务正确提交之前，不允许把事务对该数据的改变提供给任何其他事务，即在事务正确提交之前，它可能的结果不应该显示给其他事务。事务隔离分 为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重 复读（repeatable read）和串行化（Serializable）。 
* 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障 也不会丢失。 

### 11. 说一下数据库的事务隔离级别？ 

MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加： 

```
transaction-isolation = REPEATABLE-READ
```

可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。 

* READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取 （会出现幻读、脏读、不可重复读）。
* READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。
* REPEATABLE-READ：可重复读，默认级别，即在数据读出来之后加锁，类似"select * from XXX for update"，明确数据读取出来就是为了更新用的，所以要加一把锁，防止别人修改它。REPEATABLE_READ的意思也类似，读取了一条数据，这个事务不结束，别的事务就不可以改这条记录，这样就解决了脏读、不可重复读的问题，但是幻读的问题还是无法解决  。保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。 
* SERIALIZABLE：序列化，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务，这样就解决了脏读、不可重复读和幻读的问题了。   

1.脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记 录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。

2.不可重复读 ：是指在一个事务内，多次读同一数据。 

3.幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时 候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生 幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一 个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。 

### 12. 说一下事务的传播行为？

所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。Spring 在 TransactionDefinition 定义中包括了如下几个表示传播行为的常量： 

* REQUIRED： 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。
* REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。
* SUPPORTS： 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
* NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。
* NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。 
* MANDATORY： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。
* NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。

### MVCC和事务隔离级别的关系?

`MVCC`(Multi Version Concurrency Control的简称)，代表多版本并发控制。与`MVCC`相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。





### 分表以后怎么去确认数据在哪张表？

### 分表策略？

### 分表怎么解决全局唯一的主键？

uuid，雪花算法

### 分表以后查询一个范围但跨表了？怎么办？



## SQL优化问题

### 1. like 索引会失效吗？

* 通配符开头（'%abc'），索引会失效。
* 通配符结尾（'abc%'），索引不会失效。

LIKE以%开头会导致索引失效。

### 2. 必须使用`%abc%`的时候，怎么保证索引？    

使用组合索引可以解决 ，但避免使用select *  。

### 3. 组合索引?

* 带头大哥不能死       

* 中间兄弟不能断

  ![1602162068325](C:\Users\Dongbixi\AppData\Roaming\Typora\typora-user-images\1602162068325.png)   



### 4. 如何避免全表扫描？

* 避免在where 子句中对字段进行 null 值判断 

* 避免在 where 子句中使用!=或<>操作符 

* 不在索引列上做任何操作(计算、函数、类型转换)，会导致索引失效而转向全表扫描  

* 避免使用or 连接

### 5. 索引的数据结构？

提高`MySQL`效率，就是降低IO次数。

* Hash表

* 二叉树    搜索二叉树（`BST`），左边比根节点小，右边比根节点大。

  可能会退化成链表结构。

  ![1603384714846](C:\Users\Dongbixi\AppData\Roaming\Typora\typora-user-images\1603384714846.png)

* 红黑树    

  非严格意义上的平衡树，最长路径和最短路径比不超过2倍。

  查询和插入性能近似平衡，但是树高越来越深。

  ![1603384963684](C:\Users\Dongbixi\AppData\Roaming\Typora\typora-user-images\1603384963684.png)

* `AVL`树   

  严格意义上是一棵平衡树，最长路径和最短路径高度差不超过 1 。

  插入慢（旋转操作），查找效率快。

  ![1603384409189](C:\Users\Dongbixi\AppData\Roaming\Typora\typora-user-images\1603384409189.png)

  

* B树  `Max.Degree = 4` 度为4，节点至多为3。

  ![1603383716750](C:\Users\Dongbixi\AppData\Roaming\Typora\typora-user-images\1603383716750.png)

  

  

* B+树  `Max.Degree = 4` 度为4，更加均匀。

  叶子节点只存储数据，非叶子节点存储索引。

  ![1603383881470](C:\Users\Dongbixi\AppData\Roaming\Typora\typora-user-images\1603383881470.png)



### 6. MySQL 索引是怎么实现的？ 

索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。 
具体来说 `MySQL` 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找 到了完整的数据结构了，所有索引的性能也是更好的。 

### 7. MySQL两种索引类型：哈希表和B+树的区别？分别应用于什么场景？哪个比较好？ 

区别：

从时间复杂度上来说，哈希算法时间复杂度为O(1) ，更低。

适用场景：

Hash索引适合 where 后面 条件 = ， IN 这种等值查找，不适合范围查找。

B+树索引适合 where 后面 条件 > 或 <  这种范围查找。



### 8. MySQL索引为什么不用B树？B树和B+树的区别？

* 遍历更加方便 

  B+树的叶子结点都是相链的， 因此对整棵树的遍历只需要一次性遍历叶子节点就可以了，更加方便。

* IO次数更少

  B+树的非叶子结点只存索引，叶子节点存储数据，由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key。 



### 索引的分类？

主键索引

唯一索引

普通索引

全文索引

组合索引



### 主键索引和其他索引区别？

简单来说 ：主键索引是加速查询 + 列值唯一（不可以有null）+ 表中只有一个



### 主键索引使用自增和uuid数据插入的速度？



### 为什么经常更新的表不建议使用索引？

因为更新数据，那么索引结构也会变化，重新维护索引的开销比较大。

### 聚集索引和非聚集索引？

### count(1),count(*)的区别？

### MySQL调优

* 性能监控：开启慢查询日志,  set global slow_query_log=1; 开启慢查询   

* 查询计划：explain, 慢`SQL`分析 ,type 至少 `ref` 级别，非唯一性索引扫描   

* 索引优化：

```
单表优化        show index from table; 建立索引              

两表优化        left join 优先在右表加索引        
               right join 优先在左表加索引
```

* 查询优化： 

```
mysql在使用(!= 或者 <>)的时候无法使用索引会导致全表扫描
is null,is not null 也无法使用索引
like 以通配符开头('%abc')的索引也会失效
```

* 服务器参数设置

* 分区表：`mycat `中间件

* `MySQL`集群：主从复制，读写分离



### MVCC 实现原理？

LBCC：Lock-Based Concurrency Control，基于锁的并发控制。
MVCC：Multi-Version Concurrency Control，基于多版本的并发控制协议。纯粹基于锁的并发机制并发量低，MVCC是在基于锁的并发控制上的改进，主要是在读操作上提高了并发量。

MVCC 是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

### redo log 和 binlog？

这两种日志有以下三点不同。

* redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；
* binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。redo log 是循环写的，空间固定会用完；
* binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。