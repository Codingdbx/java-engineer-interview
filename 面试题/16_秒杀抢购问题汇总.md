# 秒杀/抢购问题汇总

秒杀抢购主要会出现的问题：

架构设计：

### 前端

#### 资源静态化：

秒杀一般都是特定的商品还有页面模板，现在一般都是前后端分离的，页面一般都是不会经过后端的，但是前端也要自己的服务器啊，那就把能提前放入cdn服务器的东西都放进去，反正把所有能提升效率的步骤都做一下，减少真正秒杀时候服务器的压力。  

#### 秒杀链接加盐： 

简单，把URL动态化，就连写代码的人都不知道，你就通过MD5之类的摘要算法加密随机的字符串去做url，然后通过前端代码获取url后台校验才能通过。 

#### 限流：

限流这里我觉得应该分为前端限流和后端限流。

前端限流：这个很简单，一般秒杀不会让你一直点的，一般都是点击一下或者两下然后几秒之后才可以继续点击，这也是保护服务器的一种手段。  

后端限流：秒杀的时候肯定是涉及到后续的订单生成和支付等操作，但是都只是成功的幸运儿才会走到那一步，那一旦100个产品卖光了，return了一个false，前端直接秒杀结束，然后你后端也关闭后续无效请求的介入了。 

比如：我们卖1000件商品，请求有10W，我们不需要把十万都放进来，你可以放1W请求进来，然后再进行操作，因为秒杀对于用户本身就是黑盒的，所以你怎么做的他们是没感知的，至于为啥放1W进来，而不是刚好1000，是因为会丢掉一些薅羊毛的用户，至于怎么判断，后面的风控阶段我会说。 

#### Nginx：

Nginx高性能的web服务器，并发也随便顶几万不是梦，但是我们的Tomcat只能顶几百的并发呀，那简单呀负载均衡嘛，一台服务几百，那就多搞点，在秒杀的时候多租点流量机。  

#### 风控：

这个时候就需要风控同学的介入了，在请求到达后端之前，风控可以根据账号行为分析出这个账号机器人的概率大不大，我现在负责公司的某些特殊系统，每个用户的行为都是会送到我们大数据团队进行分析处理，给你打上对应标签的。 

### 后端 

#### 服务单一职责： 

也就是我们下单是有个订单服务，用户登录管理等有个用户服务等等，那为啥我们不给秒杀也开个服务，我们把秒杀的代码业务逻辑放一起。 

单一职责的好处就是就算秒杀没抗住，秒杀库崩了，服务挂了，也不会影响到其他的服务。（高可用） 

#### Redis集群： 

之前不是说单机的Redis顶不住嘛，那简单多找几个兄弟啊，秒杀本来就是读多写少，那你们是不是瞬间想起来我之前跟你们提到过的，Redis集群，主从同步、读写分离，我们还搞点哨兵，开启持久化直接无敌高可用！ 

#### 库存预热： 

秒杀的本质，就是对库存的抢夺，每个秒杀的用户来你都去数据库查询库存校验库存，然后扣减库存，撇开性能因数，你不觉得这样好繁琐，对业务开发人员都不友好，而且数据库顶不住啊。

#### 那怎么办？

我们都知道数据库顶不住但是他的兄弟非关系型的数据库Redis能顶啊！ 

那不简单了，我们要开始秒杀前你通过定时任务或者运维同学提前把商品的库存加载到Redis中去，让整个流程都在Redis里面去做，然后等秒杀结束了，再异步的去修改库存就好了。 

但是用了Redis就有一个问题了，我们上面说了我们采用主从，就是我们会去读取库存然后再判断然后有库存才去减库存，正常情况没问题，但是高并发的情况问题就很大了。 

#### 多品几遍！！！

就比如现在库存只剩下1个了，我们高并发嘛，4个服务器一起查询了发现都是还有1个，那大家都觉得是自己抢到了，就都去扣库存，那结果就变成了-3，是的只有一个是真的抢到了，别的都是超卖的。咋办？ 

Redis本身是支持事务的，而且他有很多原子命令的，大家也可以用LUA，还可以用他的管道，乐观锁他也知支持。 





### 高并发对数据库产生的压力

使用redis缓存，缓存主要用于查询。缓存会出现的问题：

* 缓存一致性问题
* 缓存穿透问题
* 缓存击穿问题
* 缓存雪崩问题



### 竞争状态下如何解决库存的正确减少（"超卖"问题）

如何解决“超卖”问题：

* redis 队列 

  使用 redis 列表 数据结构 ，任务（json数据）先入列，然后取出队列中待处理的任务（异步）。给抢购业务起到一个缓冲的作用，推迟执行下一步生成订单、去库存的操作，减轻数据库压力。

  * LPOP

    弹出最左端的元素， 没有则返回 nil 。

  * BLPOP

    弹出列表的最左端的元素，没有则阻塞直到超时（ 在等待100秒后会返回 nil）或出现元素为止。

  * Llen 

    命令用于返回列表的长度。

* redis 分布式锁

  使用 redis 分布式锁会出现的问题：

  * 设置锁之后如果程序崩溃了，这个锁就永远释放不了
  * 
  * 加锁会有小问题，主动释放锁的时候，可能释放的是别人的锁
  * 
