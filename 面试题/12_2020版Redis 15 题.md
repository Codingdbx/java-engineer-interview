## 2020版Redis面试题

### 1. 什么是Redis? 都有哪些使用场景？

Redis 是一个使用 C 语言开发的高速缓存数据库。

* 记录帖子点赞数、点击数、评论数。
* 缓存近期热帖。
* 缓存文章详情信息。
* 记录用户会话信息。

### 2. Reids的特点？

* 单进程。
* 可持久化。
* 速度快，每秒支持100k读写。
* redis提供了丰富的数据结构。
* redis的单个命令都是原子的（执行读/写命令修改数据时，其他客户端不能够读取或修改相同的数据）。
* 支持事务。
* redis支持主从复制，支持哨兵模式。

### Redis为什么这么快？

在内存中做操作，

### 3. Redis支持的数据类型？

* string 字符串  

  Set ,Get

  ```java
  # 对不存在的键进行设置
  redis 127.0.0.1:6379> SET key "value"
  OK
  redis 127.0.0.1:6379> GET key
  "value"
   
  # 对已存在的键进行设置
  redis 127.0.0.1:6379> SET key "new-value"
  OK
  redis 127.0.0.1:6379> GET key
  "new-value"
  ```

* list 列表   

  Lpush,Rpush,Lpop,Rpop, Blpop, Brpop, Llen

  ```java
  redis 127.0.0.1:6379> BLPOP list1 100
  ```

* set 集合   

  Sadd, Smembers    

  ```java
  redis 127.0.0.1:6379> SADD myset "hello"
  (integer) 1
  redis 127.0.0.1:6379> SADD myset "foo"
  (integer) 1
  redis 127.0.0.1:6379> SADD myset "hello"
  (integer) 0
  redis 127.0.0.1:6379> SMEMBERS myset
  1) "hello"
  2) "foo"
  ```

* hash 哈希   

  Hmset, Hset,Hdel    

  ```java
  redis 127.0.0.1:6379> HSET myhash field1 "foo"
  (integer) 1
  redis 127.0.0.1:6379> HDEL myhash field1
  (integer) 1
  redis 127.0.0.1:6379> HDEL myhash field2
  (integer) 0
  ```

* zset 有序集合

  ```java
  redis 127.0.0.1:6379> ZADD myset 1 "hello"
  (integer) 1
  redis 127.0.0.1:6379> ZADD myset 1 "foo"
  (integer) 1
  redis 127.0.0.1:6379> ZADD myset 2 "world" 3 "bar"
  (integer) 2
  redis 127.0.0.1:6379> ZRANGE myzset 0 -1 WITHSCORES
  1) "hello"
  2) "1"
  3) "foo"
  4) "1"
  5) "world"
  6) "2"
  7) "bar"
  8) "3"
  ```

### 4. Redis是多线程还是单线程？ 

Redis是单线程模型，指的是执行 Redis 命令的核心模块是单线程的，而不是整个 Redis 实例就一个线程，Redis 其他模块还有各自模块的线程的。 

### 5. Redis 中哪些是原子操作？

* Lua 脚本
* 单个 Redis 命令
* "MULTI"/"EXEC" 事务

### 6. Redis 事务

以 MULTI 命令开始，EXEC 命令结束，被 MULTI 命令和 EXEC 命令包围的命令会一个接一个的执行，直到所有的命令执行完毕，Redis 才会处理其他客户端的命令。

### 7. Redis 持久化有几种方式？ 

* RDB（Redis Database）

  每隔一段时间，对你的数据进行快照存储。

* AOF（Append Only File）

  每一个收到的写命令都可以通过 write 函数追加到文件中。

断电了，Redis数据如何恢复？

RDB方式数据少一点，但是恢复起来比较快。AOF数据更全一点，但是恢复比较慢。所以应急情况下先用 RDB的方式，然后再用AOF追加那些不全的数据。

### 8. Redis 的持久化开启了RDB和AOF下重启服务是如何加载的？ 

1） AOF持久化开启且存在AOF文件时，优先加载AOF文件。
2） AOF关闭或者AOF文件不存在时，加载RDB文件。
3） 加载AOF/RDB文件成功后，Redis启动成功。
4） AOF/RDB文件存在错误时，Redis启动失败并打印错误信息。

### 10. Redis 如果做集群该如何规划？AKF/CAP如何实现和设计？

如果希望快速部署，那么可以考虑单节点部署方式。
如果只需要考虑可靠性，那么可以考虑主从复制模式。
如果想要保证高可用，不需要考虑储存成本可以考虑哨兵模式。
如果想提高集群的扩展性和可用性，不要求保证数据的强一致性，且没有批量操作，那么可以考虑集群模式。

### 10. 哨兵模式(Redis Sentinel)和集群模式(Redis Cluster)？

集群模式：

- 保证数据安全性。从节点作为主节点备份，一旦主节点不可用，从节点可以顶上去，保证了数据尽量不被丢失。

- 提高读能力。主从读写分离，横向扩展的系统的读负载。

- 集群配置：

  |      IP       |            Redis 实例            |
  | :-----------: | :------------------------------: |
  | 192.168.2.170 | Redis1(6379/主)、Redis2(6380/从) |
  | 192.168.2.142 | Redis1(6379/主)、Redis2(6380/从) |
  | 192.168.2.151 | Redis1(6379/主)、Redis2(6380/从) |

哨兵模式：

主从复制架构有一个非常致命的问题，那就是一旦主节点由于故障不可用时，需要手动将一个从节点晋升为主节点。Redis Sentinel 模式就可以解决这个问题。Redis Sentinel 是一个能够自动完成**监控**和**故障转移**并**通知**应用方。

- 监控（Monitoring）：哨兵会不断地检查主节点和从节点是否运作正常。

- 自动故障转移（Automatic failover）：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。

- 配置提供者（Configuration provider）：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。

- 通知（Notification）：哨兵可以将故障转移的结果发送给客户端。

- 哨兵配置：

  |    节点    |    IP     | 端口  |
  | :--------: | :-------: | :---: |
  |   主节点   | 127.0.0.1 | 6379  |
  |  从节点 1  | 127.0.0.1 | 6380  |
  |  从节点 2  | 127.0.0.1 | 6381  |
  | 哨兵节点 1 | 127.0.0.1 | 26379 |
  | 哨兵节点 2 | 127.0.0.1 | 26380 |
  | 哨兵节点 3 | 127.0.0.1 | 26381 |



> - 哨兵节点：哨兵系统由若干个哨兵节点组成。其实哨兵节点就是一个特殊的 Redis 节点，只不过它是不存储数据的和仅支持部分命令。
> - 数据节点：由主节点和从节点组成的数据节点。

如果哨兵模式下的一个主节点自动恢复以后，那么这个节点会成为新的主节点吗？

不会，会成为新的从节点。

### 一致性hash算法与hash算法？



### 11. Redis发布订阅

Redis Publish 命令用于将信息发送到指定的频道。 

```powershell
redis 127.0.0.1:6379> PUBLISH mychannel "hello, i m here"
(integer) 1
```

Redis Psubscribe 命令订阅一个或多个符合给定模式的频道。 

```powershell
redis 127.0.0.1:6379> PSUBSCRIBE mychannel
Reading messages... (press Ctrl-C to quit)
1) "psubscribe"
2) "mychannel"
3) (integer) 1
```



### 12. Redis 怎么实现分布式锁？ 

获取-执行-释放。SETNX 命令天生就适合来实现锁的获取功能，这个命令只会在键不存在的情况下为键设置值。
setnx(set if not exists)指令，使用完调用 del 释放锁。

存在以下问题：

* 锁超时问题

  setnx 不支持超时时间，如果获取锁的线程挂掉，那么锁就永远无法释放了。

  ```java
  setnx //不支持超时时间  setnx(key,1) 
  set  //支持超时时间 set(key,1,30,NX)
  ```

* 误删问题

  如果某些原因导致线程A执行的很慢很慢，过了30秒都没执行完，这时候锁过期自动释放，线程B得到了锁。  随后，线程A执行完了任务，线程A接着执行del指令来释放锁。但这时候线程B还没执行完，**线程A实际上删除的是线程B加的锁**。

  可以在del释放锁之前做一个判断，验证当前的锁是不是自己加的锁。 

  加锁：

  ```java
  String threadId = Thread.currentThread().getId()
  set(key,threadId,30,NX);
  ```

  解锁：

  ```java
  if(threadId.equals(redisClient.get(key))){
      del(key);
  };
  ```

  但是，这样做又隐含了一个新的问题，**判断和释放锁是两个独立操作，不是原子性**。 

  所以这一块要用Lua脚本来实现：

  ```java
  String luaScript = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";
  redisClient.eval(luaScript,Collections.singletonList(key),
                   Collections.singletonList(threadId));
  ```

### 13. Redis内存回收策略?

* noeviction：默认策略，当内存不足时，新写入操作会报错。应该没人用吧。

* allkeys-lru：当内存不足时，移除最近最少使用的 Key。推荐使用，目前项目在用这种。

* allkeys-random：当内存不足时，随机移除某个 Key。应该也没人用吧，你不删最少使用 Key，去随机删。

* volatile-lru：当内存不足时，在设置了超时时间的 key 中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。不推荐。

* volatile-random：当内存不足时，在设置了超时时间的 key 中，随机移除某个 Key。依然不推荐。

* volatile-ttl：当内存不足时，在设置了超时时间的 key 中，有更早过期时间的 Key 优先移除。不推荐。如果没有对应的键，则回退到noeviction策略。

### 14. 简述一下如何找到redis中热点数据最热的那个？

限定 Redis 占用的内存，Redis 会根据自身数据淘汰策略，留下热数据到内存。 所以，计算一下热点数据大约占用的内存，然后设置一下 Redis 内存限制即可，并将内存淘汰策略为volatile-lru或者allkeys-lru。  



虚拟内存

读写分离模型

数据分片模型

使用Redis有哪些好处？



### 18. Memcached与Redis的区别都有哪些？Redis相比Memcached有哪些优势？

相同点： 都是C语言所编写，高性能。

不同点：

* 存储方式不同：Memcached把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小，Redis 有部份存在硬盘上，这样能保证数据的持久性。 
* 数据支持类型不同：Memcached对数据类型支持相对简单，Redis 有复杂的数据类型。 
* value 值大小不同：Redis 最大可以达到 512mb，memcache 只有 1mb。 

### EhCache  特点

EhCache   是一个纯Java写的缓存框架。



### 19. Redis 常见的性能问题都有哪些？如何解决？

* 主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的， 会间断性暂停服务，所以主服务器最好不要写内存快照。
* Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。 

### 20. 如何解决缓存一致性问题？

#### 最初级的缓存不一致问题及解决方案

**解决思路**：先删除缓存，再修改数据库。如果数据库修改失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，则读数据库中旧数据，然后更新到缓存中。

#### 亿级流量高并发场景下，如何保证缓存与数据库的双写一致性

只有在对一个数据在并发的进行读写的时候，才可能会出现这种问题。 

**解决方案如下：**

更新数据库的时候，根据数据的唯一标识，将操作路由之后，发送到一个 jvm 内部队列中。

读取数据的时候，如果发现数据不在缓存中，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也发送同一个 jvm 内部队列中。

一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行。

这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新。

此时如果一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。

### 21. 什么是缓存穿透？怎么解决的？

缓存中不存在相应的数据，直接到数据库查询，数据库返回空结果，缓存中不存储空结果。 造成缓存穿透。 

比如对于系统 A，假设一秒 5000 个请求，结果其中 4000 个请求是黑客发出的恶意攻击。黑客发出的那 4000 个攻击，缓存中查不到，每次你去数据库里查，也查不到。

第一种解决方案：就是把空对象缓存起来。当第一次从数据库中查询出来的结果为空时，我们就将这个空对象加载到缓存，并设置合理的过期时间，这样，就能够在一定程度上保障后端数据库的安全。 

第二种解决缓存穿透问题的解决方案：就是使用布隆过滤器，布隆过滤器可以针对大数据量的、有规律的键值进行处理。一条记录是不是存在，本质上是一个Bool值，只需要使用 1bit 就可以存储。我们可以使用布隆过滤器将这种表示是、否等操作，压缩到一个数据结构中。比如，我们最熟悉的用户性别这种数据，就非常适合使用布隆过滤器来处理。

缓存穿透-布隆过滤器 



### 22. 什么是缓存击穿？怎么解决的？

如果缓存中的数据 Hotkey在某个时刻批量过期，导致大部分用户的请求都会直接落在数据库上，这种现象就叫作缓存击穿。 

1. 对于比较热点的数据，我们可以在缓存中设置这些数据永不过期。

2. 可以在访问数据的时候，在缓存中更新这些数据的过期时间。

3. 尽量让失效时间点均匀分布 ，避免同一时刻失效。

### 23. 什么是缓存雪崩？怎么解决的？

如果缓存系统出现故障，所有的并发流量就会直接到达数据库。数据存储层的调用量就会暴增，用不了多长时间，数据库就会被大流量压垮，这种级联式的服务故障，就叫作缓存雪崩。  

解决缓存雪崩问题最常用的一种方案就是保证Redis的高可用，将Redis缓存部署成高可用集群(必要时候做成异地多活)，可以有效的防止缓存雪崩问题的发生。 

 